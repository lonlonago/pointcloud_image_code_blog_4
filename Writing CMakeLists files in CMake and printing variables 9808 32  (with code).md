Recently in the learning PCL, in Win10 using VS to write PCL programs, configuration environment often error, step pit records see: Win10 + VS2017 + PCL_1 software installation, step pit records 

 I saw that cmke was used in the book "Point Cloud Library PCL From Entry to Mastery". I found that using cmake is more concise and fast, and it is not easy to make mistakes. Test records: Use Cmake to compile PCL project files under Win10 for testing 

#  Preparation of CMakeLists files 

 With cmake, the most crucial step is to write the CMakeLists file. Then record the commands commonly used in PCL. 

 CMakeLists.txt file example: 

>  cmake_minimum_required(VERSION 2.8 FATAL_ERROR)

project(pcd_write)

find_package(PCL 1.2 REQUIRED)

include_directories(${PCL_INCLUDE_DIRS}) link_directories(${PCL_LIBRARY_DIRS}) add_definitions(${PCL_DEFINITIONS})

add_executable (pcd_write pcd_write.cpp) target_link_libraries (pcd_write ${PCL_LIBRARIES}) 

 Explanation:  

>  Define the minimum version, which is mandatory for cmake because you are doing a very basic project that does not require functionality from cmake 2.8 or higher. cmake_minimum_required (version 2.8 FATAL_ERROR) 

>  Project name project (pcd_write)//The pcd_write here is the name of the project folder 

>  find_package () command is used to find the dependency package, you can put a whole dependency package header file including path, library path, library name, version number and so on are obtained to find_package (PCL 1.2 REQUIRED)

We asked to find the PCL package with a minimum version of 1.2, if not, it will fail

Since PCL is modular, it is possible to:

Only one component: find_package (PCL 1.3 REQUIRED COMPONENTS io) Some: find_package (PCL 1.3 REQUIRED COMPONENTS io common) All already exists: find_package (PCL 1.3 REQUIRED) 

>  include_directories(${PCL_INCLUDE_DIRS})

link_directories(${PCL_LIBRARY_DIRS})

add_definitions(${PCL_DEFINITIONS}) 

  When the PCL is found, some relevant variables will be set: 

 To let cmake know what external header files are included in the project, you need to use include_directories macros. In our case, PCL_INCLUDE_DIRS contains what we need, so we ask cmake to search the path it contains for possible header files. 

>  include_directories (${PCL_INCLUDE_DIRS}) parameter form * _INCLUDE_DIRS, the variable is find_package path and other paths that need to be included 

>  link_directories (${PCL_LIBRARY_DIRS}) is used to load the additional library function path, the path of the linked library file, which is sometimes not necessary. Because find_package and find_library directives can get the absolute path of the library file. 

>  add_excutable (pcd_write pcd_write cpp) use the given source file to introduce an executable file for the project

Here we tell cmake that we are trying to create an executable named pcd_write from a source file pcd_write .cpp. CMake will add the suffix (.exe on Windows and blank on UNIX) and permissions. 

>  add_dependencies () is generally not used. The case used is that the two targets have dependencies (solved by target_link_libraries) and the dependency library is also generated by compiling the source code. At this time, add_dependencies can automatically check whether the lower-level dependency library has been generated when directly compiling the upper-level target. If not, compile the lower-level dependency library first, then compile the upper-level target, and finally link depends target 

>  target_link_libraries (pcd_write ${PCL_LIBRARIES}) to add a linked library; link the target file to the library file.

The executable we are building calls the PCL function. So far we have only included the PCL header file, so the compiler knows which method we are calling. We also need to let the linker know which library we are linking to. As mentioned earlier, use the PCL libraries variable to reference the library found by PCL, and all that is left is the linking operation that triggers us to call the target link library () macro. 

 PCLConfig.cmake uses a special CMake feature called EXPORT, which allows you to work with other project targets as if you were building them yourself. When using such targets, they are called import targets and act like any other target. 

#  Printing of Cmake variables 

 The message method in Cmake is message, which is used to output log information in the cmake project during compilation, and can also be used to view log information at any time during breakpoint debugging.  

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309573614925
  ```  
>  Message: Message name, can be entered in the CMakeLists.txt or .cmake script file, and there is a prompt, insensitive to case mode: Print the type of message, there are FATAL_ERROR, SEND_ERROR, WARNING, AUTHOR_WARNING, DEPRECATION, (none) or NOTICE, STATUS, VERBOSE, DEBUG, TRACE A total of 10 "message to display": The content of the output message, is a string type...: Represents variable parameters, can be connected to multiple output 

##  Mode - type of print message 

  Example of use: 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309573614925
  ```  
 Output result: 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309573614925
  ```  
 Reference link: 

 Using PCL in your own project — Point Cloud Library 0.0 documentation 

 https://blog.csdn.net/Calvin_zhou/article/details/104025714 

